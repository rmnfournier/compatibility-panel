import argparse
import glob
import os
import re
import pandas as pd


def get_arguments():
    parser = argparse.ArgumentParser(description="Obtain a list of SNPs from annotation data")
    parser.add_argument('--annotations', type=str, help='path/to/annotation_chr@.txt', required=True)
    parser.add_argument('--snp_file',
                        type=str,
                        required=True,
                        help="path to a .snp file (snp_name\tchr\tmap\tpos\tref\talt).\
                        Only snp_name, chromosome and position are required, the rest can be placeholder.")
    parser.add_argument('--quantile',
                        type=float,
                        required=True,
                        help="The proportion of SNPs to keep")
    parser.add_argument('--out', type=str, help='Output file for snps to keep', required=True)
    parser.add_argument('--out2', type=str, help='Output file for snps to discard', required=False, default=None)
    parser.add_argument('--method', type=str, choices=['freq', 'chi2', 'bayes'], required=True,
                        help='Annotation method used for the annotation.')

    args = parser.parse_args()
    return args


def get_method_score_direction(method):
    """
    By default, a high score means that we want to keep the SNP.
    """
    score_direction = {
        "freq": 'inverted',
        "chi2": 'default',
        "bayes": 'default'
    }
    if method not in score_direction:
        valid_methods = ", ".join(score_direction.keys())
        raise ValueError(f"Method must be one of: {valid_methods}")
    return score_direction[method]


def load_and_annotate_snps(annotation_loc, snp_file):
    snp_file = load_snp_df(snp_file)
    annotations = load_annotations(annotation_loc)

    try:
        snp_file['chr'] = snp_file['chr'].astype(str)
        snp_file['pos'] = pd.to_numeric(snp_file['pos'], errors='raise').astype(int)

        annotations['chr'] = annotations['chr'].astype(str)
        annotations['pos'] = pd.to_numeric(annotations['pos'], errors='raise').astype(int)
    except Exception as e:
        raise ValueError(f"Failed to normalize 'chr'/'pos' types before merge: {e}")

    annotated_snps = pd.merge(snp_file, annotations, how='inner', left_on=['chr', 'pos'], right_on=['chr', 'pos'])

    return annotated_snps


def load_snp_df(snp_file):
    try:
        snp_df = pd.read_csv(snp_file, sep=r"\s+", header=None, engine='python')
        snp_df.columns = ['snp', 'chr', 'gen_map', 'pos', 'ref', 'alt']
        return snp_df
    except Exception as e:
        raise ValueError(f"Failed to load SNP file '{snp_file}': {e}")


def load_annotations(annotation_loc):
    """
    Load all annotations files generated by this package.
    Parameters
    ----------
    annotation_loc : str
        Path to annotation files, with a chr@ placeholder for chromosome or id.
        If '@' is present the function will glob for all matching files.
    Returns
        dataframe
    -------
    """
    annotations = []

    if "@" in annotation_loc:
        pattern = annotation_loc.replace("@", "*")
        files = sorted(glob.glob(pattern))
        if not files:
            raise FileNotFoundError(f"No annotation files found for pattern: {pattern}")

        prefix, suffix = annotation_loc.split("@", 1)
        prefix_esc = re.escape(prefix)
        suffix_esc = re.escape(suffix)
        regex = re.compile(rf"^{prefix_esc}(.+?){suffix_esc}$")

        for f in files:
            try:
                m = regex.match(f)
                if m:
                    id_val = m.group(1)
                else:
                    id_val = os.path.splitext(os.path.basename(f))[0]
                annot_df = pd.read_csv(f, sep=",")
                annot_df['chr'] = id_val
                annotations.append(annot_df)
            except Exception as e:
                raise RuntimeError(f"Failed to read annotation file '{f}': {e}")
    else:
        if not os.path.exists(annotation_loc):
            raise FileNotFoundError(f"Annotation file not found: {annotation_loc}")
        annot_df = pd.read_csv(annotation_loc, sep="\t")
        annotations.append(annot_df)

    if not annotations:
        return pd.DataFrame()
    annotations = pd.concat(annotations, ignore_index=True)
    return annotations


def save_results(sorted_snps, quantile, out, out2, snp_file):
    sorted_snps = sorted_snps[['snp']]
    n_snps = len(sorted_snps)
    n_to_keep = int(n_snps * quantile)
    to_keep = sorted_snps.iloc[:n_to_keep]

    to_keep.to_csv(out, sep="\t", index=False, header=False)
    if out2:
        snp_df = load_snp_df(snp_file)
        to_discard = snp_df[~snp_df['snp'].isin(to_keep['snp'])][['snp']]
        to_discard.to_csv(out2, sep="\t", index=False, header=False)


def main():
    args = get_arguments()
    direction = get_method_score_direction(args.method)
    annotated_snps = load_and_annotate_snps(args.annotations, args.snp_file)
    sorted_snps = annotated_snps.sort_values(by='score', ascending=(direction == 'inverted'))
    save_results(sorted_snps, args.quantile, args.out, args.out2, args.snp_file)
